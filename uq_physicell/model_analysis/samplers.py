import numpy as np

from SALib.sample import fast_sampler, ff, finite_diff, latin, sobol

def get_SA_problem(params_dict: dict) -> dict:
    """
    Create a problem dictionary for SALib based on the provided parameters.
    Parameters:
    - params_dict: Dictionary containing parameter names and their properties.
    Returns:
    - problem: Dictionary formatted for SALib analysis.
    """
    param_names = [key for key in params_dict.keys() if key != "samples"]
    problem = {
        'num_vars': len(param_names),
        'names': param_names,
        'bounds': [(params_dict[key]['lower_bounds'], params_dict[key]['upper_bounds']) for key in param_names]
    }
    return problem

def run_global_sampler(params_dict, sampler, N=None, M=4, seed=42):
    """
    Run the global sampler based on the specified method.
    Parameters:
    - params_dict: Dictionary containing parameter names and their properties.
    - sampler: String indicating the sampling method to use.
    - N: Number of samples to generate (default is None, which will be set later).
    - M: Number of harmonics for the Fast sampler (default is 4).
    Returns:
    - global_samples_dict: Dictionary of dictionaries containing the generated samples.
    """

    # Define the problem for SALib
    problem = get_SA_problem(params_dict)
    if sampler == "Fast":
        # Generate model inputs for extended Fourier Amplitude Sensitivity Test.
        # Returns a NumPy matrix containing the model inputs required by the extended Fourier Amplitude sensitivity test. 
        # The resulting matrix contains N * D rows and D columns, where D is the number of parameters.
        # N: The number of samples to generate
        # M: The interference parameter, i.e., the number of harmonics to sum in the Fourier series decomposition (default 4)
        try:
            global_samples = fast_sampler.sample(problem, N, M=M, seed=seed)
        except Exception as e:
            raise ValueError(f"Error in Fast sampler: {e}")
    elif sampler == "Fractional Factorial":
        # Generates model inputs using a fractional factorial sample.
        # Returns a NumPy matrix containing the model inputs required for a fractional factorial analysis. 
        # The resulting matrix has D columns, where D is smallest power of 2 that is greater than the number of parameters. 
        # These model inputs are intended to be used with SALib.analyze.ff.analyze(). 
        try:
            global_samples = ff.sample(problem, seed=seed)
        except Exception as e:
            raise ValueError(f"Error in Fractional Factorial sampler: {e}")
    elif sampler == "Finite Difference":
        # Generate matrix of samples for Derivative-based Global Sensitivity Measure (DGSM).
        # Start from a QMC (Sobol’) sequence and finite difference with delta % steps
        try:
            global_samples = finite_diff.sample(problem, seed=seed)
        except Exception as e:
            raise ValueError(f"Error in Finite Difference sampler: {e}")
    elif sampler == "Latin hypercube sampling (LHS)":
        # Generate model inputs using Latin hypercube sampling (LHS).
        # Returns a NumPy matrix containing the model inputs generated by Latin hypercube sampling. 
        # The resulting matrix contains N rows and D columns, where D is the number of parameters.
        try:
            global_samples = latin.sample(problem, N, seed=seed)
        except Exception as e:
            raise ValueError(f"Error in Latin hypercube sampling sampler: {e}")
    elif sampler == "Sobol":
        # Generates model inputs using Saltelli’s extension of the Sobol’ sequence.
        # The Sobol’ sequence is a popular quasi-random low-discrepancy sequence used to generate uniform samples of parameter space.
        # If second-order indices: N*(2D+2) sample if only first-order indices: N*(D+2) samples, where D is the number of parameters
        try:
            global_samples = sobol.sample(problem, N, calc_second_order=True, seed=seed)
        except Exception as e:
            raise ValueError(f"Error in Sobol sampler: {e}")
    else:
        raise ValueError("Error: Invalid sampler selected.")
    
    # Convert the samples to a dictionary of dictionaries - sorted by sample ID
    global_samples_dict = {i: dict(zip(problem['names'], global_samples[i])) for i in range(len(global_samples))}
    
    return global_samples_dict

def run_local_sampler(params_dict, sampler='OAT'):
    """
    Run the local sampler based on the specified method.
    Parameters:
    - params_dict: Dictionary containing parameter names and their properties.
    - sampler: String indicating the sampling method to use (default is 'OAT' for One-At-A-Time).
    Returns:
    - local_samples: NumPy array containing the generated samples.
    """
    params_ref = {key: params_dict[key]["ref_value"] for key in params_dict.keys()}
    # First sample is the reference value
    local_samples_dict = {0: params_ref}
    for id, par in enumerate(params_dict.keys()):
        perturbations = np.array(params_dict[par]["perturbation"])
        perturbations = np.concatenate((-perturbations, perturbations))  # Combine negative and positive perturbations
        for idx, var in enumerate(perturbations):
            sample_id = id * len(perturbations) + idx + 1  # Unique sample ID for each perturbation
            if sample_id not in local_samples_dict: # Avoid overwriting existing samples
                local_samples_dict[sample_id] = params_ref.copy()  # Start with reference values
            local_samples_dict[sample_id][par] = params_ref[par] * (1 + var / 100.0)

    return local_samples_dict